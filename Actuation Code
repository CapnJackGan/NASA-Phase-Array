//This code is written for the Arduino MEGA
//The purpose of this code is to take a user defined polar coordinate or preset and reconfigure an array to match those coordinates
/*Notable functions:
StepperMotor (int StepCount, const int dirPin, const int stepPin )
see Pinout chart for pins
*/
int DELAY=1000; //delay between steps in miliseconds

/*Code Structure:
-Variables
-Pinouts
-Setup
   -Pin Setup
   -Initiate Interupts
   -Serial Setup
   -Call StartUp
-Interupt Functions
-Define Interupt Function
-StepperMotor Function
-ExecuteSteps Function
   -Frequency Presets
   -Run to positions/control loop
-StartUp Function
*/

//Serial communications: Baud rate = 250000

struct Encoder {
  long Counter;
  char State;
};

//Variable encoder states
Encoder Radial1 = {10000, 'A'};
Encoder Radial2 = {10000, 'A'};
Encoder Axial1 = {10000, 'A'};
Encoder Axial2 = {10000, 'A'};

//Set Pins, see pinout chart
//For shift registers, Data to pin 14 SER, PMW to 11 SRCLK, Latch 12 RCLK, pull pin 16 and 10 high and ground pin 8 and 13
const int Ring1RadialSteps = 2; //Ring 1 Radial
const int Ring1RadialDir = 3;
const int Ring1RadialEncoderChannelA = 4;
const int Ring1RadialEncoderChannelB = 5;
const int Ring1AxialSteps = 6; //Ring 1 Axial
const int Ring1AxialDir = 7;
const int Ring1AxialEncoderChannelA = 8;
const int Ring1AxialEncoderChannelB = 9;
const int Ring2RadialSteps = 10; //Ring 2 Radial
const int Ring2RadialDir = 11;
const int Ring2RadialEncoderChannelA = 12;
const int Ring2RadialEncoderChannelB = 13;
const int Ring2AxialSteps = 14; //Ring 2 Axial
const int Ring2AxialDir = 15;
const int Ring2AxialEncoderChannelA = 16;
const int Ring2AxialEncoderChannelB = 17;

void setup() {
  //configure pins to input or output
  pinMode(Ring1RadialSteps, OUTPUT);
  pinMode(Ring1RadialDir, OUTPUT);
  pinMode(Ring1AxialSteps, OUTPUT);
  pinMode(Ring1AxialDir, OUTPUT);
  pinMode(Ring1RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2RadialSteps, OUTPUT);
  pinMode(Ring2RadialDir, OUTPUT);
  pinMode(Ring2AxialSteps, OUTPUT);
  pinMode(Ring2AxialDir, OUTPUT);
  pinMode(Ring2RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelB, INPUT_PULLUP);
  
  //initiate encoder interupts
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelA), Ring1RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelB), Ring1RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelA), Ring1AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelB), Ring1AxialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelA), Ring2RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelB), Ring2RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelA), Ring2AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelB), Ring2AxialEncoderBInterrupt, CHANGE);

  //Iniatiate serial port
  Serial.begin(250000);

//Launch Startup Sequence
  StartUp();
}

//Encoder interupts
Encoder Ring1RadialEncoderAInterrupt() {
  Radial1 = EncoderInterupt(Radial1.State, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Radial1.Counter);
  return Radial1;
}

Encoder Ring1RadialEncoderBInterrupt() { 
  Radial1 = EncoderInterupt(Radial1.State, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Radial1.Counter);
  return Radial1;
}

Encoder Ring1AxialEncoderAInterrupt() {
  Axial1 = EncoderInterupt(Axial1.State, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Axial1.Counter);
  return Axial1;
}

Encoder Ring1AxialEncoderBInterrupt() {
  Axial1 = EncoderInterupt(Axial1.State, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Axial1.Counter);
  return Axial1;
}

//Ring 2 interupts
Encoder Ring2RadialEncoderAInterrupt() {
  Radial2 = EncoderInterupt(Radial2.State, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Radial2.Counter);
  return Radial1;
}

Encoder Ring2RadialEncoderBInterrupt() { 
  Radial2 = EncoderInterupt(Radial2.State, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Radial2.Counter);
  return Radial2;
}

Encoder Ring2AxialEncoderAInterrupt() {
  Axial2 = EncoderInterupt(Axial2.State, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Axial2.Counter);
  return Axial2;
}

Encoder Ring2AxialEncoderBInterrupt() {
  Axial1 = EncoderInterupt(Axial2.State, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Axial2.Counter);
  return Axial2;
}

Encoder EncoderInterupt(char State, int ChannelA, int ChannelB, long EncoderCounter) {
  char Previous = State;
  int A = digitalRead(ChannelA);
  int B = digitalRead(ChannelB);
  //Find encoder state
  if (A == HIGH && B == HIGH) {
    State = 'A';
  }
  else if (A == HIGH && B == LOW) {
    State = 'D';
  }
  else if (A == LOW && B == HIGH) {
    State = 'B';
  }
  else {
    State = 'C';
  }
  //Finds encoder direction using encoder states
  if (Previous == 'A') {
    if (State == 'B') {
      EncoderCounter++;
    }
    else if (State == 'D') {
      EncoderCounter--;
    }
  }
  else if (Previous == 'B') {
    if (State == 'C') {
      EncoderCounter++;
    }
    else if (State == 'A') {
      EncoderCounter--;
    }
  }
  else if (Previous == 'C') {
    if (State == 'D') {
      EncoderCounter++;
    }
    else if (State == 'B') {
      EncoderCounter--;
    }
  }
  else if (Previous == 'D') {
    if (State == 'A') {
     EncoderCounter++;
    }
    else if (State == 'C') {
      EncoderCounter--;
    }
  }
  Encoder Temp{EncoderCounter, State};
  return Temp;
}

//This function runs the motor
void StepperMotor (int StepCount, const int dirPin, const int stepPin ) {
  if (StepCount > 0) {
    digitalWrite(dirPin,HIGH); // Enables the motor to move in a particular direction
      }
  else if (StepCount < 0) {
    digitalWrite(dirPin,HIGH); // Enables the motor to move in a particular direction
      }
 // Makes 200 pulses for making one full cycle rotation
 StepCount = abs(StepCount);
    for(int x = 0; x < StepCount; x++) {
        digitalWrite(stepPin,HIGH);
        delay(DELAY);
        digitalWrite(stepPin,LOW);
        delay(DELAY);
    }
}

//The following is how far the motors need to move to get to their intended position
void ExecuteSteps(){
  Serial.println("Please enter your desired frequency");
  Serial.println("Available presets: 1125, 1800, 2825, 4500, 7150, 11250, 16000");
  int Frequency;
  if (Serial.available() > 0) {
    // read the incoming byte:
    Frequency = Serial.read();
  }
int desiredposition;
int desiredposition2;
int intendedposition;
int intendedposition2;

if (Frequency = 16000 ) {  
//Running motors for axial locations
int desiredposition = (25); //determining the position in terms of steps
int desiredposition2 = (110); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 115200;
int intendedposition2 = 47040;
}

else if (Frequency = 11250) {
int desiredposition = (81); //determining the position in terms of steps
int desiredpositoin2 = (47); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 147200;
int intendedposition2 = 75520;
}

else if (Frequency = 7150) {
int desiredposition = (103); //determining the position in terms of steps
int desiredpositoin2 = (78); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 179200;
int intendedposition2 = 103680;
    }
    
  else if (Frequency = 4500) {
int desiredposition = (148); //determining the position in terms of steps
int desiredpositoin2 = (93); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 211200;
int intendedposition2 = 131848;
    }
    
  else if (Frequency = 2825) {
int desiredposition = (169); //determining the position in terms of steps
int desiredpositoin2 = (113); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 243200;
int intendedposition2 = 160068;
    }

  else if (Frequency = 1800) {
int desiredposition = (136); //determining the position in terms of steps
int desiredpositoin2 = (38); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 275200;
int intendedposition2 = 188288;
    }

  else if (Frequency = 1125) {
int desiredposition = (175); //determining the position in terms of steps
int desiredpositoin2 = (149); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 307200;
int intendedposition2 = 216512;
    }
  else {
    Serial.println("Error! You did not enter a valid frequency"); //If they do not enter one of the 7 frequencies it will not move
  }
  
  int x = 0;
while(x==0){
  int Direction;
if (abs(desiredposition - Axial1.Counter) > 2){
  if (desiredposition - Axial1.Counter > 0){
    Direction = 1;
  }
  else{
    Direction = -1;
  }
  StepperMotor(Direction, Ring1AxialDir, Ring1AxialSteps);
}

if (abs(desiredposition - Axial2.Counter) > 2){
  if (desiredposition2 - Axial2.Counter > 0){
    Direction = 1;
  }
  else{
    Direction = -1;
  }
  StepperMotor(Direction, Ring2AxialDir, Ring2AxialSteps); //Motor will move
}

if (abs(intendedposition - Radial1.Counter) > 2){
  if (intendedposition - Radial1.Counter > 0){
    Direction = 10;
  }
  else{
    Direction = -10;
  }
StepperMotor(Direction, Ring1RadialDir, Ring1RadialSteps); //Motor Will move  
}

if (abs(intendedposition - Radial2.Counter) > 2){
  if (intendedposition - Radial2.Counter > 0){
    Direction = 10;
  }
  else{
    Direction = -10;
  }
  StepperMotor(Direction, Ring2RadialDir, Ring2RadialSteps); //Motor will move  
}
//if all encoders are within 2 steps of the desired position, end
if (abs(desiredposition - Axial1.Counter) <= 2 && abs(desiredposition - Axial2.Counter) <= 2
&& abs(desiredposition - Radial1.Counter) <= 2 && abs(desiredposition - Radial2.Counter) <= 2){
  x=1;
}
}
}

//StartUp function, this zeros the array and encoders
void StartUp (){
  while( Radial1.Counter && Axial1.Counter && Radial1.Counter && Axial1.Counter != 0){
    
  int PrevRadial1Counter = Radial1.Counter;
  if (Radial1.Counter != 0){
  StepperMotor (-2, Ring1RadialDir, Ring1RadialSteps );
  if (PrevRadial1Counter-Radial1.Counter >=1){
    Radial1.Counter=0;
  }
}

  int PrevAxial1Counter = Axial1.Counter;
  if (Axial1.Counter != 0){
  StepperMotor (-2, Ring1RadialDir, Ring1RadialSteps );
  if (PrevAxial1Counter-Axial1.Counter >=1){
    Axial1.Counter=0;
  }
}

  int PrevRadial2Counter = Radial2.Counter;
  if (Radial2.Counter != 0){
  StepperMotor (-2, Ring2RadialDir, Ring2RadialSteps );
  if (PrevRadial2Counter-Radial2.Counter >=1){
    Radial2.Counter=0;
  }
}

  int PrevAxial2Counter = Axial2.Counter;
  if (Axial2.Counter != 0){
  StepperMotor (-2, Ring2RadialDir, Ring2RadialSteps );
  if (PrevAxial2Counter-Axial2.Counter >=1){
    Axial2.Counter=0;
  }
}
  }
}

void loop() {
ExecuteSteps();
}
