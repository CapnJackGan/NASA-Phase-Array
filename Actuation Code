//This code is written for the Arduino MEGA
//The purpose of this code is to take a user defined polar coordinate or preset and reconfigure an array to match those coordinates
/*Notable functions:
   MotorState = StepperMotor (int StepCount, char MotorState, int LP, int DP )
   MotorState are listed in variable
   StepCount is the number of steps in 0.9Â° increments due to half stepping
   LP is the Latch Pin, see pinout chart
   DP is the Data Pin, see pinout chart
*/

/*Code Structure:
-Variables
-Pinouts
-Setup
   -Pin Setup
   -Initiate Interupts
   -Serial Setup
   -Call StartUp
-Interupt Functions
-Define Interupt Function
-StepperMotor Function
-ExecuteSteps Function
   -Frequency Presets
   -Run to positions/control loop
-StartUp Function
*/

//Serial communications: Baud rate = 250000

struct Encoder {
  long Counter;
  char State;
};

//Variablescoder states

Encoder Radial1 = {10000, 'A'};
Encoder Radial2 = {10000, 'A'};
Encoder Axial1 = {10000, 'A'};
Encoder Axial2 = {10000, 'A'};
char Ring1RadialMotorState = 'A'; //Motor step states
char Ring1AxialMotorState = 'A';
char Ring2RadialMotorState = 'A';
char Ring2AxialMotorState = 'A';

//Set Pins, see pinout chart
//For shift registers, Data to pin 14 SER, PMW to 11 SRCLK, Latch 12 RCLK, pull pin 16 and 10 high and ground pin 8 and 13
const int Ring1RadialMotorLatchPin = 2; //Ring 1 Radial
const int Ring1RadialMotorDataPin = 3;
const int PWM = 4;
const int Ring1AxialMotorLatchPin = 6; //Ring 1 Axial
const int Ring1AxialMotorDataPin = 7;
const int Ring1RadialEncoderChannelA = 8;
const int Ring1RadialEncoderChannelB = 9;
const int Ring1RadialEncoderIndex = 10;
const int Ring1AxialEncoderChannelA = 11;
const int Ring1AxialEncoderChannelB = 12;
const int Ring1AxialEncoderIndex = 13;
const int Ring2RadialMotorLatchPin = 22; //Ring 2 Radial
const int Ring2RadialMotorDataPin = 23;
const int Ring2AxialMotorLatchPin = 24; //Ring 2 Axial
const int Ring2AxialMotorDataPin = 25;
const int Ring2RadialEncoderChannelA = 26;
const int Ring2RadialEncoderChannelB = 27;
const int Ring2RadialEncoderIndex = 28;
const int Ring2AxialEncoderChannelA = 29;
const int Ring2AxialEncoderChannelB = 30;
const int Ring2AxialEncoderIndex = 31;

void setup() {
  //configure pins to input or output
  pinMode(PWM, OUTPUT);
  pinMode(Ring1RadialMotorLatchPin, OUTPUT);
  pinMode(Ring1RadialMotorDataPin, OUTPUT);
  pinMode(Ring1AxialMotorLatchPin, OUTPUT);
  pinMode(Ring1AxialMotorDataPin, OUTPUT);
  pinMode(Ring1RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring2RadialMotorLatchPin, OUTPUT);
  pinMode(Ring2RadialMotorDataPin, OUTPUT);
  pinMode(Ring2AxialMotorLatchPin, OUTPUT);
  pinMode(Ring2AxialMotorDataPin, OUTPUT);
  pinMode(Ring2RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderIndex, INPUT_PULLUP);
  
  //initiate encoder interupts
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelA), Ring1RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelB), Ring1RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelA), Ring1AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelB), Ring1AxialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelA), Ring2RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelB), Ring2RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelA), Ring2AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelB), Ring2AxialEncoderBInterrupt, CHANGE);

  //Iniatiate serial port
  Serial.begin(250000);

//Launch Startup Sequence
  StartUp();
}

//Encoder interupts
Encoder Ring1RadialEncoderAInterrupt() {
  Radial1 = EncoderInterupt(Radial1.State, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Radial1.Counter);
  return Radial1;
}

Encoder Ring1RadialEncoderBInterrupt() { 
  Radial1 = EncoderInterupt(Radial1.State, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Radial1.Counter);
  return Radial1;
}

Encoder Ring1AxialEncoderAInterrupt() {
  Axial1 = EncoderInterupt(Axial1.State, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Axial1.Counter);
  return Axial1;
}

Encoder Ring1AxialEncoderBInterrupt() {
  Axial1 = EncoderInterupt(Axial1.State, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Axial1.Counter);
  return Axial1;
}

//Ring 2 interupts
Encoder Ring2RadialEncoderAInterrupt() {
  Radial2 = EncoderInterupt(Radial2.State, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Radial2.Counter);
  return Radial1;
}

Encoder Ring2RadialEncoderBInterrupt() { 
  Radial2 = EncoderInterupt(Radial2.State, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Radial2.Counter);
  return Radial2;
}

Encoder Ring2AxialEncoderAInterrupt() {
  Axial2 = EncoderInterupt(Axial2.State, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Axial2.Counter);
  return Axial2;
}

Encoder Ring2AxialEncoderBInterrupt() {
  Axial1 = EncoderInterupt(Axial2.State, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Axial2.Counter);
  return Axial2;
}

Encoder EncoderInterupt(char State, int ChannelA, int ChannelB, long EncoderCounter) {
  char Previous = State;
  int A = digitalRead(ChannelA);
  int B = digitalRead(ChannelB);
  //Find encoder state
  if (A == HIGH && B == HIGH) {
    State = 'A';
  }
  else if (A == HIGH && B == LOW) {
    State = 'D';
  }
  else if (A == LOW && B == HIGH) {
    State = 'B';
  }
  else {
    State = 'C';
  }
  //Finds encoder direction using encoder states
  if (Previous == 'A') {
    if (State == 'B') {
      EncoderCounter++;
    }
    else if (State == 'D') {
      EncoderCounter--;
    }
  }
  else if (Previous == 'B') {
    if (State == 'C') {
      EncoderCounter++;
    }
    else if (State == 'A') {
      EncoderCounter--;
    }
  }
  else if (Previous == 'C') {
    if (State == 'D') {
      EncoderCounter++;
    }
    else if (State == 'B') {
      EncoderCounter--;
    }
  }
  else if (Previous == 'D') {
    if (State == 'A') {
     EncoderCounter++;
    }
    else if (State == 'C') {
      EncoderCounter--;
    }
  }
  Encoder Temp{EncoderCounter, State};
  return Temp;
}

//This function runs the motor
char StepperMotor (int StepCount, char MotorState, const int LP, const int DP ) {
  
  byte data;

  if (StepCount > 0) {
    for (int i = 0; i <= StepCount; i++) {
      //implement state machine here
      if (MotorState == 'A') {
        data = 0b00000110;
        MotorState = 'B';
      }
      else if (MotorState == 'B') {
        data = 0b00000100;
        MotorState = 'C';
      }
      else if (MotorState == 'C') {
        data = 0b00001100;
        MotorState = 'D';
      }
      else if (MotorState == 'D') {
        data = 0b00001000;
        MotorState = 'E';
      }
      else if (MotorState == 'E') {
        data = 0b00011000;
        MotorState = 'F';
      }
      else if (MotorState == 'F') {
        data = 0b00010000;
        MotorState = 'G';
      }
      else if (MotorState == 'G') {
        data = 0b00010010;
        MotorState = 'H';
      }
      else if (MotorState == 'H') {
        data = 0b00000010;
        MotorState = 'A';
      }
      digitalWrite(LP, LOW);
      shiftOut(DP, 4, MSBFIRST, data);//4 is the PWM pin
      digitalWrite (LP, HIGH);
      delay(20);//delay used so motor doesn't try to spin impossibly fast, specific number needs fine tuning
    }
  }
  else if (StepCount < 0) {
    while (StepCount != 0) {
      //implement state machine here but reversed
      if (MotorState == 'H') {
        data = 0b00010000;
        MotorState = 'G';
      }
      else if (MotorState == 'G') {
        data = 0b00011000;
        MotorState = 'F';
      }
      else if (MotorState == 'F') {
        data = 0b00001000;
        MotorState = 'E';
      }
      else if (MotorState == 'E') {
        data = 0b00001100;
        MotorState = 'D';
      }
      else if (MotorState == 'D') {
        data = 0b00000100;
        MotorState = 'C';
      }
      else if (MotorState == 'C') {
        data = 0b00000110;
        MotorState = 'B';
      }
      else if (MotorState == 'B') {
        data = 0b00000010;
        MotorState = 'A';
      }
      else if (MotorState == 'A') {
        data = 0b00010010;
        MotorState = 'H';
      }
      StepCount++;
      digitalWrite(LP, LOW);
      shiftOut(DP, 4, MSBFIRST, data); //4 is the PWM pin
      digitalWrite (LP, HIGH);
      delay(20);//delay used so motor doesn't try to spin impossibly fast
    }
  }
  return MotorState;
}

//The following is how far the motors need to move to get to their intended position
void ExecuteSteps(){
  Serial.println("Please enter your desired frequency");
  Serial.println("Available presets: 1125, 1800, 2825, 4500, 7150, 11250, 16000");
  int Frequency;
  if (Serial.available() > 0) {
    // read the incoming byte:
    Frequency = Serial.read();
  }
int desiredposition;
int desiredposition2;
int intendedposition;
int intendedposition2;

if (Frequency = 16000 ) {  
//Running motors for axial locations
int desiredposition = (5.6/.9); //determining the position in terms of steps
int desiredposition2 = (24.7/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 28800;
int intendedposition2 = 11760;
}

else if (Frequency = 11250) {
int desiredposition = (18.32/.9); //determining the position in terms of steps
int desiredpositoin2 = (10.6/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 36800;
int intendedposition2 = 18880;
}

else if (Frequency = 7150) {
int desiredposition = (23.07/.9); //determining the position in terms of steps
int desiredpositoin2 = (17.45/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 44800;
int intendedposition2 = 25920;
    }
    
  else if (Frequency = 4500) {
int desiredposition = (33.348/.9); //determining the position in terms of steps
int desiredpositoin2 = (20.88/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 52800;
int intendedposition2 = 32962;
    }
    
  else if (Frequency = 2825) {
int desiredposition = (37.965/.9); //determining the position in terms of steps
int desiredpositoin2 = (25.495/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 60800;
int intendedposition2 = 40017;
    }

  else if (Frequency = 1800) {
int desiredposition = (30.679/.9); //determining the position in terms of steps
int desiredpositoin2 = (8.52/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 68800;
int intendedposition2 = 47072;
    }

  else if (Frequency = 1125) {
int desiredposition = (39.466/.9); //determining the position in terms of steps
int desiredpositoin2 = (33.43/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 76800;
int intendedposition2 = 54128;
    }
  else {
    Serial.println("Error! You did not enter a valid frequency"); //If they do not enter one of the 7 frequencies it will not move
  }
  
  int x = 0;
while(x==0){
  int Direction;
if (abs(desiredposition - Axial1.Counter) > 2){
  if (desiredposition - Axial1.Counter > 0){
    Direction = 1;
  }
  else{
    Direction = -1;
  }
  Ring1AxialMotorState = StepperMotor(Direction, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin);
}

if (abs(desiredposition - Axial2.Counter) > 2){
  if (desiredposition2 - Axial2.Counter > 0){
    Direction = 1;
  }
  else{
    Direction = -1;
  }
Ring2AxialMotorState = StepperMotor(Direction, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
}

if (abs(intendedposition - Radial1.Counter) > 2){
  if (intendedposition - Radial1.Counter > 0){
    Direction = 10;
  }
  else{
    Direction = -10;
  }
Ring1RadialMotorState = StepperMotor(Direction, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move  
}

if (abs(intendedposition - Radial2.Counter) > 2){
  if (intendedposition - Radial2.Counter > 0){
    Direction = 10;
  }
  else{
    Direction = -10;
  }
Ring2RadialMotorState = StepperMotor(Direction, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move  
}
//if all encoders are within 2 steps of the desired position, end
if (abs(desiredposition - Axial1.Counter) <= 2 && abs(desiredposition - Axial2.Counter) <= 2
&& abs(desiredposition - Radial1.Counter) <= 2 && abs(desiredposition - Radial2.Counter) <= 2){
  x=1;
}
}
}

//StartUp function, this zeros the array and encoders
void StartUp (){
  while( Radial1.Counter && Axial1.Counter && Radial1.Counter && Axial1.Counter != 0){
    
  int PrevRadial1Counter = Radial1.Counter;
  if (Radial1.Counter != 0){
  Ring1RadialMotorState = StepperMotor (-2, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin );
  if (PrevRadial1Counter-Radial1.Counter >=1){
    Radial1.Counter=0;
  }
}

  int PrevAxial1Counter = Axial1.Counter;
  if (Axial1.Counter != 0){
  Ring1AxialMotorState = StepperMotor (-2, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin );
  if (PrevAxial1Counter-Axial1.Counter >=1){
    Axial1.Counter=0;
  }
}

  int PrevRadial2Counter = Radial2.Counter;
  if (Radial2.Counter != 0){
  Ring2RadialMotorState = StepperMotor (-2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin );
  if (PrevRadial2Counter-Radial2.Counter >=1){
    Radial2.Counter=0;
  }
}

  int PrevAxial2Counter = Axial2.Counter;
  if (Axial2.Counter != 0){
  Ring2AxialMotorState = StepperMotor (-2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin );
  if (PrevAxial2Counter-Axial2.Counter >=1){
    Axial2.Counter=0;
  }
}
  }
}

void loop() {
ExecuteSteps();
}
