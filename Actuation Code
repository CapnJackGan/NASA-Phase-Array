//This code is written for the Arduino IDE
//The purpose of this code is to take a user defined polar coordinate and reconfigure an array to match those coordinates
/*Notable functions:
   MotorState = StepperMotor (int StepCount, char MotorState, int LP, int DP )
   MotorState are listed in variable
   StepCount is the number of steps in 0.9Â° increments due to half stepping
   LP is the Latch Pin, see pinout chart
   DP is the Data Pin, see pinout chart
*/

//Variables
int Ring1RadialEncoderCounter = 10000; //counter to keep track of encoder position. Initially set high for startup sequence
int Ring1AxialEncoderCounter = 10000;
int Ring2RadialEncoderCounter = 10000;
int Ring2AxialEncoderCounter = 10000;
char Ring1RadialEncoderState = 'A'; //Encoder states
char Ring1AxialEncoderState = 'A';
char Ring2RadialEncoderState = 'A';
char Ring2AxialEncoderState = 'A';
char Ring1RadialMotorState = 'A'; //Motor step states
char Ring1AxialMotorState = 'A';
char Ring2RadialMotorState = 'A';
char Ring2AxialMotorState = 'A';

//Set Pins, see pinout chart
//For shift registers, Data to pin 14 SER, PMW to 11 SRCLK, Latch 12 RCLK, pull pin 16 and 10 high and ground pin 8 and 13
const int Ring1RadialMotorLatchPin = 2; //Ring 1 Radial
const int Ring1RadialMotorDataPin = 3;
const int PWM = 4;
const int Ring1AxialMotorLatchPin = 6; //Ring 1 Axial
const int Ring1AxialMotorDataPin = 7;
const int Ring1RadialEncoderChannelA = 8;
const int Ring1RadialEncoderChannelB = 9;
const int Ring1RadialEncoderIndex = 10;
const int Ring1AxialEncoderChannelA = 11;
const int Ring1AxialEncoderChannelB = 12;
const int Ring1AxialEncoderIndex = 13;
const int Ring2RadialMotorLatchPin = 22; //Ring 2 Radial
const int Ring2RadialMotorDataPin = 23;
const int Ring2AxialMotorLatchPin = 24; //Ring 2 Axial
const int Ring2AxialMotorDataPin = 25;
const int Ring2RadialEncoderChannelA = 26;
const int Ring2RadialEncoderChannelB = 27;
const int Ring2RadialEncoderIndex = 28;
const int Ring2AxialEncoderChannelA = 29;
const int Ring2AxialEncoderChannelB = 30;
const int Ring2AxialEncoderIndex = 31;

void setup() {
  //configure pins to input or output
  pinMode(PWM, OUTPUT);
  pinMode(Ring1RadialMotorLatchPin, OUTPUT);
  pinMode(Ring1RadialMotorDataPin, OUTPUT);
  pinMode(Ring1AxialMotorLatchPin, OUTPUT);
  pinMode(Ring1AxialMotorDataPin, OUTPUT);
  pinMode(Ring1RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring2RadialMotorLatchPin, OUTPUT);
  pinMode(Ring2RadialMotorDataPin, OUTPUT);
  pinMode(Ring2AxialMotorLatchPin, OUTPUT);
  pinMode(Ring2AxialMotorDataPin, OUTPUT);
  pinMode(Ring2RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderIndex, INPUT_PULLUP);
  
  //initiate encoder interupts
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelA), Ring1RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelB), Ring1RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelA), Ring1AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelB), Ring1AxialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelA), Ring2RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelB), Ring2RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelA), Ring2AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelB), Ring2AxialEncoderBInterrupt, CHANGE);
}

//Encoder interupts
void Ring1RadialEncoderAInterrupt() {
  EncoderInterupt(Ring1RadialEncoderState, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Ring1RadialEncoderCounter);
}

void Ring1RadialEncoderBInterrupt() {
  EncoderInterupt(Ring1RadialEncoderState, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Ring1RadialEncoderCounter);
}

void Ring1AxialEncoderAInterrupt() {
  EncoderInterupt(Ring1AxialEncoderState, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Ring1AxialEncoderCounter);
}

void Ring1AxialEncoderBInterrupt() {
  EncoderInterupt(Ring1AxialEncoderState, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Ring1AxialEncoderCounter);
}
//Ring 2 interupts
void Ring2RadialEncoderAInterrupt() {
  EncoderInterupt(Ring2RadialEncoderState, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Ring2RadialEncoderCounter);
}

void Ring2RadialEncoderBInterrupt() {
  EncoderInterupt(Ring2RadialEncoderState, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Ring2RadialEncoderCounter);
}

void Ring2AxialEncoderAInterrupt() {
  EncoderInterupt(Ring2AxialEncoderState, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Ring2AxialEncoderCounter);
}

void Ring2AxialEncoderBInterrupt() {
  EncoderInterupt(Ring2AxialEncoderState, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Ring2AxialEncoderCounter);
}

//Encoder interupt function
void EncoderInterupt(char State, int ChannelA, int ChannelB, int EncoderCounter) {
  char Previous = State;
  int A = digitalRead(ChannelA);
  int B = digitalRead(ChannelB);
  //Find encoder state
  if (A == HIGH && B == HIGH) {
    State = 'A';
  }
  else if (A == HIGH && B == LOW) {
    State = 'B';
  }
  else if (A == LOW && B == HIGH) {
    State = 'C';
  }
  else {
    State = 'D';
  }
  //Finds encoder direction using encoder states
  if (Previous == 'A') {
    if (State == 'B') {
      EncoderCounter++;
    }
    else if (State == 'C') {
      EncoderCounter--;
    }
  }
  if (Previous == 'B') {
    if (State == 'D') {
      EncoderCounter++;
    }
    else if (State == 'A') {
      EncoderCounter--;
    }
  }
  if (Previous == 'C') {
    if (State == 'A') {
      EncoderCounter++;
    }
    else if (State == 'D') {
      EncoderCounter--;
    }
  }
  if (Previous == 'D') {
    if (State == 'C') {
     EncoderCounter++;
    }
    else if (State == 'B') {
      EncoderCounter--;
    }
  }
}

//This function runs the motor
char StepperMotor (int StepCount, char MotorState, const int LP, const int DP ) {
  byte data;

  if (StepCount > 0) {
    for (int i = 0; i <= StepCount; i++) {
      //implement state machine here
      if (MotorState == 'A') {
        data = 0b00000110;
        MotorState = 'B';
      }
      else if (MotorState == 'B') {
        data = 0b00000100;
        MotorState = 'C';
      }
      else if (MotorState == 'C') {
        data = 0b00001100;
        MotorState = 'D';
      }
      else if (MotorState == 'D') {
        data = 0b00001000;
        MotorState = 'E';
      }
      else if (MotorState == 'E') {
        data = 0b00011000;
        MotorState = 'F';
      }
      else if (MotorState == 'F') {
        data = 0b00010000;
        MotorState = 'G';
      }
      else if (MotorState == 'G') {
        data = 0b00010010;
        MotorState = 'H';
      }
      else if (MotorState == 'H') {
        data = 0b00000010;
        MotorState = 'A';
      }
      digitalWrite(LP, LOW);
      shiftOut(DP, 4, MSBFIRST, data);//4 is the PWM pin
      digitalWrite (LP, HIGH);
      delay(250);//delay used so motor doesn't try to spin impossibly fast, specific number needs fine tuning
    }
  }
  else if (StepCount < 0) {
    while (StepCount != 0) {
      //implement state machine here but reversed
      if (MotorState == 'H') {
        data = 0b00010000;
        MotorState = 'G';
      }
      else if (MotorState == 'G') {
        data = 0b00011000;
        MotorState = 'F';
      }
      else if (MotorState == 'F') {
        data = 0b00001000;
        MotorState = 'E';
      }
      else if (MotorState == 'E') {
        data = 0b00001100;
        MotorState = 'D';
      }
      else if (MotorState == 'D') {
        data = 0b00000100;
        MotorState = 'C';
      }
      else if (MotorState == 'C') {
        data = 0b00000110;
        MotorState = 'B';
      }
      else if (MotorState == 'B') {
        data = 0b00000010;
        MotorState = 'A';
      }
      else if (MotorState == 'A') {
        data = 0b00010010;
        MotorState = 'H';
      }
      StepCount++;
      digitalWrite(LP, LOW);
      shiftOut(DP, 4, MSBFIRST, data); //4 is the PWM pin
      digitalWrite (LP, HIGH);
      delay(250);//delay used so motor doesn't try to spin impossibly fast
    }
  }
  return MotorState;
}

//The following is how far the motors need to move to get to their intended position
int Frequency = ;  //Where these people need to enter in desired frequency, no idea how to do this
int stepstoangle; //This integer will hold how many steps we need to get to the closest angle to 0degrees
int stepstoangle2;
int stepstoradius; //This integer will hold how many steps we need to get to proper radius
int stepstoradius2;


if (Frequency = 16000 ) {
  void Movement() {
    
//Running motors for axial locations

int desiredposition = (5.6/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (24.707); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out


// Now running the motors for the radial distances

int intendedposition = 28800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 11760;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out
 
  }
}
else if (Frequency = 11250) {
  void Movement() {

  int desiredposition = (18.32/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (10.6/.9); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out


// Now running the motors for the radial distances

int intendedposition = 36800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 18880;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out

  }
  else if (Frequency = 7150) {
    void Movement() {
      
    int desiredposition = (23.07/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (17.45/.9); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out


// Now running the motors for the radial distances

int intendedposition = 44800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 25920;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out
    }

  }
  else if (Frequency = 4500) {
    void Movement() {
      
int desiredposition = (33.348/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (20.88/.9); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out


// Now running the motors for the radial distances

int intendedposition = 52800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 32962.4;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out
    }
  }
  else if (Frequency = 2825) {
    void Movement() {
      
int desiredposition = (37.965/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (25.495/.9); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out

// Now running the motors for the radial distances

int intendedposition = 60800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 40017.7;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out

    }

  }
  else if (Frequency = 1800) {
    void Movement() {
      
    int desiredposition = (30.679/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (8.52/.9); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out

// Now running the motors for the radial distances

int intendedposition = 68800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 47072;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out

    }

  }
  else if (Frequency = 1125) {
    void Movement() {

    int desiredposition = (39.466/.9); //determining the position in terms of steps
stepstoangle = desiredposition - Ring1AxialEncoderState; //determining how far the motor needs to move to the new position
Ring1AxialMotorState = StepperMotor(stepstoangle, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin); //Motor will move
Serial.println(Ring1AxialEncoderState); //Calls the new encoder count to print out

int desiredpositoin2 = (33.43/.9); //determining the position in terms of steps
stepstoangle2 = desiredposition2 - Ring2AxialEncoderState; //determining how far the motor needs to move to the new position
Ring2AxialMotorState = StepperMotor(stepstoangle2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
Serial.println(Ring2AxialEncoderState); //Calls the new encoder count to print out

// Now running the motors for the radial distances

int intendedposition = 76800;
stepstoradius = intendedposition - Ring1RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring1RadialMotorState = StepperMotor(stepstoradius, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move
Serial.println(Ring1RadialEncoderState); //Calls the new encoder count to print out

int intendedposition2 = 54128;
stepstoradius2 = intendedposition2 - Ring2RadialEncoderState; //Determining how far the motor needs to move to the new position
Ring2RadialMotorState = StepperMotor(stepstoradius2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move
Serial.println(Ring2RadialEncoderState); //Calls the new encoder count to print out

    }

  }
  else {
    Serial.println("Error! You did not enter a valid frequency"); //If they do not enter one of the 7 frequencies it will not move
  }


//StartUp function, this zeros the array and encoders
void StartUp (){
  while( Ring1RadialEncoderCounter && Ring1AxialEncoderCounter && Ring1RadialEncoderCounter && Ring1AxialEncoderCounter != 0){
    
  int PrevRing1RadialEncoderCounter = Ring1RadialEncoderCounter;
  if (Ring1RadialEncoderCounter != 0){
  Ring1RadialMotorState = StepperMotor (-2, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin );
  if (PrevRing1RadialEncoderCounter-Ring1RadialEncoderCounter >=1){
    Ring1RadialEncoderCounter=0;
  }
}

  int PrevRing1AxialEncoderCounter = Ring1AxialEncoderCounter;
  if (Ring1AxialEncoderCounter != 0){
  Ring1AxialMotorState = StepperMotor (-2, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin );
  if (PrevRing1AxialEncoderCounter-Ring1AxialEncoderCounter >=1){
    Ring1AxialEncoderCounter=0;
  }
}

  int PrevRing2RadialEncoderCounter = Ring2RadialEncoderCounter;
  if (Ring2RadialEncoderCounter != 0){
  Ring2RadialMotorState = StepperMotor (-2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin );
  if (PrevRing2RadialEncoderCounter-Ring2RadialEncoderCounter >=1){
    Ring2RadialEncoderCounter=0;
  }
}

  int PrevRing2AxialEncoderCounter = Ring2AxialEncoderCounter;
  if (Ring2AxialEncoderCounter != 0){
  Ring2AxialMotorState = StepperMotor (-2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin );
  if (PrevRing2AxialEncoderCounter-Ring2AxialEncoderCounter >=1){
    Ring2AxialEncoderCounter=0;
  }
}
  }
}

void loop() {

  Ring1AxialMotorState = StepperMotor (-100, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin );
}
