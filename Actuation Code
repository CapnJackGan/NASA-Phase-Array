//This code is written for the Arduino IDE
//The purpose of this code is to take a user defined polar coordinate and reconfigure an array to match those coordinates
/*Notable functions:
   MotorState = StepperMotor (int StepCount, char MotorState, int LP, int DP )
   MotorState are listed in variable
   StepCount is the number of steps in 0.9Â° increments due to half stepping
   LP is the Latch Pin, see pinout chart
   DP is the Data Pin, see pinout chart
*/

//Variables
int Ring1RadialEncoderCounter = 100000; //counter to keep track of encoder position. Initially set high for startup sequence
int Ring1AxialEncoderCounter = 10000;
int Ring2RadialEncoderCounter = 100000;
int Ring2AxialEncoderCounter = 10000;
char Ring1RadialEncoderState = 'A'; //Encoder states
char Ring1AxialEncoderState = 'A';
char Ring2RadialEncoderState = 'A';
char Ring2AxialEncoderState = 'A';
char Ring1RadialMotorState = 'A'; //Motor step states
char Ring1AxialMotorState = 'A';
char Ring2RadialMotorState = 'A';
char Ring2AxialMotorState = 'A';

//Set Pins, see pinout chart
//For shift registers, Data to pin 14 SER, PMW to 11 SRCLK, Latch 12 RCLK, pull pin 16 and 10 high and ground pin 8 and 13
const int Ring1RadialMotorLatchPin = 2; //Ring 1 Radial
const int Ring1RadialMotorDataPin = 3;
const int PWM = 4;
const int Ring1AxialMotorLatchPin = 6; //Ring 1 Axial
const int Ring1AxialMotorDataPin = 7;
const int Ring1RadialEncoderChannelA = 8;
const int Ring1RadialEncoderChannelB = 9;
const int Ring1RadialEncoderIndex = 10;
const int Ring1AxialEncoderChannelA = 11;
const int Ring1AxialEncoderChannelB = 12;
const int Ring1AxialEncoderIndex = 13;
const int Ring2RadialMotorLatchPin = 22; //Ring 2 Radial
const int Ring2RadialMotorDataPin = 23;
const int Ring2AxialMotorLatchPin = 24; //Ring 2 Axial
const int Ring2AxialMotorDataPin = 25;
const int Ring2RadialEncoderChannelA = 26;
const int Ring2RadialEncoderChannelB = 27;
const int Ring2RadialEncoderIndex = 28;
const int Ring2AxialEncoderChannelA = 29;
const int Ring2AxialEncoderChannelB = 30;
const int Ring2AxialEncoderIndex = 31;

void setup() {
  //configure pins to input or output
  pinMode(PWM, OUTPUT);
  pinMode(Ring1RadialMotorLatchPin, OUTPUT);
  pinMode(Ring1RadialMotorDataPin, OUTPUT);
  pinMode(Ring1AxialMotorLatchPin, OUTPUT);
  pinMode(Ring1AxialMotorDataPin, OUTPUT);
  pinMode(Ring1RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1RadialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring1AxialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring2RadialMotorLatchPin, OUTPUT);
  pinMode(Ring2RadialMotorDataPin, OUTPUT);
  pinMode(Ring2AxialMotorLatchPin, OUTPUT);
  pinMode(Ring2AxialMotorDataPin, OUTPUT);
  pinMode(Ring2RadialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2RadialEncoderIndex, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelA, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderChannelB, INPUT_PULLUP);
  pinMode(Ring2AxialEncoderIndex, INPUT_PULLUP);
  
  //initiate encoder interupts
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelA), Ring1RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelB), Ring1RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelA), Ring1AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelB), Ring1AxialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelA), Ring2RadialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelB), Ring2RadialEncoderBInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelA), Ring2AxialEncoderAInterrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelB), Ring2AxialEncoderBInterrupt, CHANGE);

  //Iniatiate serial port
  Serial.begin(9600);

//Launch Startup Sequence
  StartUp();
}

//Encoder interupts
void Ring1RadialEncoderAInterrupt() {
  EncoderInterupt(Ring1RadialEncoderState, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Ring1RadialEncoderCounter);
}

void Ring1RadialEncoderBInterrupt() {
  EncoderInterupt(Ring1RadialEncoderState, Ring1RadialEncoderChannelA, Ring1RadialEncoderChannelB, Ring1RadialEncoderCounter);
}

void Ring1AxialEncoderAInterrupt() {
  EncoderInterupt(Ring1AxialEncoderState, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Ring1AxialEncoderCounter);
}

void Ring1AxialEncoderBInterrupt() {
  EncoderInterupt(Ring1AxialEncoderState, Ring1AxialEncoderChannelA, Ring1AxialEncoderChannelB, Ring1AxialEncoderCounter);
}
//Ring 2 interupts
void Ring2RadialEncoderAInterrupt() {
  EncoderInterupt(Ring2RadialEncoderState, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Ring2RadialEncoderCounter);
}

void Ring2RadialEncoderBInterrupt() {
  EncoderInterupt(Ring2RadialEncoderState, Ring2RadialEncoderChannelA, Ring2RadialEncoderChannelB, Ring2RadialEncoderCounter);
}

void Ring2AxialEncoderAInterrupt() {
  EncoderInterupt(Ring2AxialEncoderState, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Ring2AxialEncoderCounter);
}

void Ring2AxialEncoderBInterrupt() {
  EncoderInterupt(Ring2AxialEncoderState, Ring2AxialEncoderChannelA, Ring2AxialEncoderChannelB, Ring2AxialEncoderCounter);
}

//Encoder interupt function
void EncoderInterupt(char State, int ChannelA, int ChannelB, int EncoderCounter) {
  char Previous = State;
  int A = digitalRead(ChannelA);
  int B = digitalRead(ChannelB);
  //Find encoder state
  if (A == HIGH && B == HIGH) {
    State = 'A';
  }
  else if (A == HIGH && B == LOW) {
    State = 'B';
  }
  else if (A == LOW && B == HIGH) {
    State = 'C';
  }
  else {
    State = 'D';
  }
  //Finds encoder direction using encoder states
  if (Previous == 'A') {
    if (State == 'B') {
      EncoderCounter++;
    }
    else if (State == 'C') {
      EncoderCounter--;
    }
  }
  if (Previous == 'B') {
    if (State == 'D') {
      EncoderCounter++;
    }
    else if (State == 'A') {
      EncoderCounter--;
    }
  }
  if (Previous == 'C') {
    if (State == 'A') {
      EncoderCounter++;
    }
    else if (State == 'D') {
      EncoderCounter--;
    }
  }
  if (Previous == 'D') {
    if (State == 'C') {
     EncoderCounter++;
    }
    else if (State == 'B') {
      EncoderCounter--;
    }
  }
}

//This function runs the motor
char StepperMotor (int StepCount, char MotorState, const int LP, const int DP ) {
  
  byte data;

  if (StepCount > 0) {
    for (int i = 0; i <= StepCount; i++) {
      //implement state machine here
      if (MotorState == 'A') {
        data = 0b00000110;
        MotorState = 'B';
      }
      else if (MotorState == 'B') {
        data = 0b00000100;
        MotorState = 'C';
      }
      else if (MotorState == 'C') {
        data = 0b00001100;
        MotorState = 'D';
      }
      else if (MotorState == 'D') {
        data = 0b00001000;
        MotorState = 'E';
      }
      else if (MotorState == 'E') {
        data = 0b00011000;
        MotorState = 'F';
      }
      else if (MotorState == 'F') {
        data = 0b00010000;
        MotorState = 'G';
      }
      else if (MotorState == 'G') {
        data = 0b00010010;
        MotorState = 'H';
      }
      else if (MotorState == 'H') {
        data = 0b00000010;
        MotorState = 'A';
      }
      digitalWrite(LP, LOW);
      shiftOut(DP, 4, MSBFIRST, data);//4 is the PWM pin
      digitalWrite (LP, HIGH);
      delay(20);//delay used so motor doesn't try to spin impossibly fast, specific number needs fine tuning
    }
  }
  else if (StepCount < 0) {
    while (StepCount != 0) {
      //implement state machine here but reversed
      if (MotorState == 'H') {
        data = 0b00010000;
        MotorState = 'G';
      }
      else if (MotorState == 'G') {
        data = 0b00011000;
        MotorState = 'F';
      }
      else if (MotorState == 'F') {
        data = 0b00001000;
        MotorState = 'E';
      }
      else if (MotorState == 'E') {
        data = 0b00001100;
        MotorState = 'D';
      }
      else if (MotorState == 'D') {
        data = 0b00000100;
        MotorState = 'C';
      }
      else if (MotorState == 'C') {
        data = 0b00000110;
        MotorState = 'B';
      }
      else if (MotorState == 'B') {
        data = 0b00000010;
        MotorState = 'A';
      }
      else if (MotorState == 'A') {
        data = 0b00010010;
        MotorState = 'H';
      }
      StepCount++;
      digitalWrite(LP, LOW);
      shiftOut(DP, 4, MSBFIRST, data); //4 is the PWM pin
      digitalWrite (LP, HIGH);
      delay(20);//delay used so motor doesn't try to spin impossibly fast
    }
  }
  return MotorState;
}

//The following is how far the motors need to move to get to their intended position
void ExecuteSteps(){
  Serial.println("Please enter your desired frequency");
  int Frequency;
  if (Serial.available() > 0) {
    // read the incoming byte:
    Frequency = Serial.read();
  }
int desiredposition;
int desiredposition2;
int intendedposition;
int intendedposition2;

if (Frequency = 16000 ) {  
//Running motors for axial locations
int desiredposition = (5.6/.9); //determining the position in terms of steps
int desiredposition2 = (24.7/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 28800;
int intendedposition2 = 11760;
}

else if (Frequency = 11250) {
int desiredposition = (18.32/.9); //determining the position in terms of steps
int desiredpositoin2 = (10.6/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 36800;
int intendedposition2 = 18880;
}

else if (Frequency = 7150) {
int desiredposition = (23.07/.9); //determining the position in terms of steps
int desiredpositoin2 = (17.45/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 44800;
int intendedposition2 = 25920;
    }
    
  else if (Frequency = 4500) {
int desiredposition = (33.348/.9); //determining the position in terms of steps
int desiredpositoin2 = (20.88/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 52800;
int intendedposition2 = 32962;
    }
    
  else if (Frequency = 2825) {
int desiredposition = (37.965/.9); //determining the position in terms of steps
int desiredpositoin2 = (25.495/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 60800;
int intendedposition2 = 40017;
    }

  else if (Frequency = 1800) {
int desiredposition = (30.679/.9); //determining the position in terms of steps
int desiredpositoin2 = (8.52/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 68800;
int intendedposition2 = 47072;
    }

  else if (Frequency = 1125) {
int desiredposition = (39.466/.9); //determining the position in terms of steps
int desiredpositoin2 = (33.43/.9); //determining the position in terms of steps

// Now running the motors for the radial distances
int intendedposition = 76800;
int intendedposition2 = 54128;
    }
  else {
    Serial.println("Error! You did not enter a valid frequency"); //If they do not enter one of the 7 frequencies it will not move
  }
  
  int x = 0;
while(x==0){
  int Direction;
if (abs(desiredposition - Ring1AxialEncoderCounter) > 2){
  if (desiredposition - Ring1AxialEncoderCounter > 0){
    Direction = 1;
  }
  else{
    Direction = -1;
  }
  Ring1AxialMotorState = StepperMotor(Direction, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin);
}

if (abs(desiredposition - Ring2AxialEncoderCounter) > 2){
  if (desiredposition2 - Ring2AxialEncoderCounter > 0){
    Direction = 1;
  }
  else{
    Direction = -1;
  }
Ring2AxialMotorState = StepperMotor(Direction, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin); //Motor will move
}

if (abs(intendedposition - Ring1RadialEncoderCounter) > 2){
  if (intendedposition - Ring1RadialEncoderCounter > 0){
    Direction = 10;
  }
  else{
    Direction = -10;
  }
Ring1RadialMotorState = StepperMotor(Direction, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin); //Motor Will move  
}

if (abs(intendedposition - Ring2RadialEncoderCounter) > 2){
  if (intendedposition - Ring2RadialEncoderCounter > 0){
    Direction = 10;
  }
  else{
    Direction = -10;
  }
Ring2RadialMotorState = StepperMotor(Direction, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin); //Motor will move  
}
//if all encoders are within 2 steps of the desired position, end
if (abs(desiredposition - Ring1AxialEncoderCounter) <= 2 && abs(desiredposition - Ring2AxialEncoderCounter) <= 2
&& abs(desiredposition - Ring1RadialEncoderCounter) <= 2 && abs(desiredposition - Ring2RadialEncoderCounter) <= 2){
  x=1;
}
}
}

//StartUp function, this zeros the array and encoders
void StartUp (){
  while( Ring1RadialEncoderCounter && Ring1AxialEncoderCounter && Ring1RadialEncoderCounter && Ring1AxialEncoderCounter != 0){
    
  int PrevRing1RadialEncoderCounter = Ring1RadialEncoderCounter;
  if (Ring1RadialEncoderCounter != 0){
  Ring1RadialMotorState = StepperMotor (-2, Ring1RadialMotorState, Ring1RadialMotorLatchPin, Ring1RadialMotorDataPin );
  if (PrevRing1RadialEncoderCounter-Ring1RadialEncoderCounter >=1){
    Ring1RadialEncoderCounter=0;
  }
}

  int PrevRing1AxialEncoderCounter = Ring1AxialEncoderCounter;
  if (Ring1AxialEncoderCounter != 0){
  Ring1AxialMotorState = StepperMotor (-2, Ring1AxialMotorState, Ring1AxialMotorLatchPin, Ring1AxialMotorDataPin );
  if (PrevRing1AxialEncoderCounter-Ring1AxialEncoderCounter >=1){
    Ring1AxialEncoderCounter=0;
  }
}

  int PrevRing2RadialEncoderCounter = Ring2RadialEncoderCounter;
  if (Ring2RadialEncoderCounter != 0){
  Ring2RadialMotorState = StepperMotor (-2, Ring2RadialMotorState, Ring2RadialMotorLatchPin, Ring2RadialMotorDataPin );
  if (PrevRing2RadialEncoderCounter-Ring2RadialEncoderCounter >=1){
    Ring2RadialEncoderCounter=0;
  }
}

  int PrevRing2AxialEncoderCounter = Ring2AxialEncoderCounter;
  if (Ring2AxialEncoderCounter != 0){
  Ring2AxialMotorState = StepperMotor (-2, Ring2AxialMotorState, Ring2AxialMotorLatchPin, Ring2AxialMotorDataPin );
  if (PrevRing2AxialEncoderCounter-Ring2AxialEncoderCounter >=1){
    Ring2AxialEncoderCounter=0;
  }
}
  }
}

void loop() {
ExecuteSteps();
}
