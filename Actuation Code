//This code is written for the Arduino IDE
//The purpose of this code is to take a user defined polar coordinate and reconfigure an array to match those coordinates

//Variables
int latchPin = 1;
int dataPin = 1;
int Ring1RadialEncoder = 1; //counter to keep track of encoder position
int Ring1AxialEncoder = 1;
int Ring2RadialEncoder = 1;
int Ring2AxialEncoder = 1;
char Ring1RadialEncoderState = 'A'; //Encoder states
char Ring1AxialEncoderState = 'A';
char Ring2RadialEncoderState = 'A';
char Ring2AxialEncoderState = 'A';
char Ring1RadialMotorState = 'A'; //Motor step states
char Ring1AxialMotorState = 'A';
char Ring2RadialMotorState = 'A';
char Ring2AxialMotorState = 'A';

//Set Pins, see pinout chart
const int Ring1RadialLimitSwitch = 2;
const int Ring1AxialLimitSwitch = 3;
const int PWM = 4;
const int Ring1MotorLatchPin = 6;
const int Ring1MotorDataPin = 7;
const int Ring1RadialEncoderChannelA = 8;
const int Ring1RadialEncoderChannelB = 9;
const int Ring1RadialEncoderIndex = 10;
const int Ring1AxialEncoderChannelA = 11;
const int Ring1AxialEncoderChannelB = 12;
const int Ring1AxialEncoderIndex = 13;
const int Ring1Brake = 15;
const int Ring2RadialLimitSwitch = 20;
const int Ring2AxialLimitSwitch = 21;
const int Ring2MotorLatchPin = 24;
const int Ring2MotorDataPin = 25;
const int Ring2RadialEncoderChannelA = 26;
const int Ring2RadialEncoderChannelB = 27;
const int Ring2RadialEncoderIndex = 28;
const int Ring2AxialEncoderChannelA = 29;
const int Ring2AxialEncoderChannelB = 30;
const int Ring2AxialEncoderIndex = 31;
const int Ring2Brake = 33;

void setup() {
//configure pins to input or output
pinMode(Ring1RadialLimitSwitch, INPUT);
pinMode(Ring1AxialLimitSwitch, INPUT);
pinMode(PWM, OUTPUT);
pinMode(Ring1MotorLatchPin, OUTPUT);
pinMode(Ring1MotorDataPin, OUTPUT);
pinMode(Ring1RadialEncoderChannelA, INPUT_PULLUP);
pinMode(Ring1RadialEncoderChannelB, INPUT_PULLUP);
pinMode(Ring1RadialEncoderIndex, INPUT_PULLUP);
pinMode(Ring1AxialEncoderChannelA, INPUT_PULLUP);
pinMode(Ring1AxialEncoderChannelB, INPUT_PULLUP);
pinMode(Ring1AxialEncoderIndex, INPUT_PULLUP);
pinMode(Ring1Brake, OUTPUT);
pinMode(Ring2RadialLimitSwitch, INPUT);
pinMode(Ring2AxialLimitSwitch, INPUT);
pinMode(Ring2MotorLatchPin, OUTPUT);
pinMode(Ring2MotorDataPin, OUTPUT);
pinMode(Ring2RadialEncoderChannelA, INPUT_PULLUP);
pinMode(Ring2RadialEncoderChannelB, INPUT_PULLUP);
pinMode(Ring2RadialEncoderIndex, INPUT_PULLUP);
pinMode(Ring2AxialEncoderChannelA, INPUT_PULLUP);
pinMode(Ring2AxialEncoderChannelB, INPUT_PULLUP);
pinMode(Ring2AxialEncoderIndex, INPUT_PULLUP);
pinMode(Ring2Brake, OUTPUT);
Serial.begin(9600);
Serial.println("reset");
//initiate encoder interupts
attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelA), Ring1RadialEncoderAInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring1RadialEncoderChannelB), Ring1RadialEncoderBInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelA), Ring1AxialEncoderAInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring1AxialEncoderChannelB), Ring1AxialEncoderBInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelA), Ring2RadialEncoderAInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring2RadialEncoderChannelB), Ring2RadialEncoderBInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelA), Ring2AxialEncoderAInterrupt, CHANGE);
attachInterrupt(digitalPinToInterrupt(Ring2AxialEncoderChannelB), Ring2AxialEncoderBInterrupt, CHANGE);
}

//encoder interupt
void Ring1RadialEncoderAInterrupt(){
  //implement state machine and copy paste x7
  int A = digitalRead(Ring1RadialEncoderChannelA);  
  int B = digitalRead(Ring1RadialEncoderChannelB);  
}

// This function sends bits to the shift register for running the stepper motor
void registerWrite(int whichPin, int whichState, int whichRing) {
// the bits you want to send
  byte bitsToSend = 0;
if (whichRing == 1){
  latchPin = Ring1MotorLatchPin;
  dataPin = Ring1MotorDataPin;
}
else if (whichRing == 2){
  latchPin = Ring2MotorLatchPin;
  dataPin = Ring2MotorDataPin;
}
  // turn off the output so the pins don't go high while shifting bits
  digitalWrite(latchPin, LOW);

  // turn on the next highest bit in bitsToSend:
  bitWrite(bitsToSend, whichPin, whichState);

  // shift the bits out:
  shiftOut(dataPin, PWM, MSBFIRST, bitsToSend);

    // turn on the output so the LEDs can light up:
  digitalWrite(latchPin, HIGH);
}

//This function runs the motor
void StepperMotor (int StepCount){
  //set motor
while(StepCount !=0){
  if(StepCount > 0){
  //implement state machine here
  }
  else{
    //if but reversed
  }
}
}

//StartUp function, this zeros the array and encoders
void StartUp (){
  while( Ring1RadialEncoder && Ring1AxialEncoder && Ring1RadialEncoder && Ring1AxialEncoder != 0){
  digitalRead(Ring1RadialLimitSwitch);
  if (Ring1RadialLimitSwitch == LOW) {
    StepperMotor (1);
  }
  else{
    Ring1RadialEncoder=0;
  }
  digitalRead(Ring1AxialLimitSwitch);
  if (Ring1AxialLimitSwitch == LOW) {
    StepperMotor (1);
  }
  else{
    Ring1AxialEncoder=0;
  }
  digitalRead(Ring2RadialLimitSwitch);
  if (Ring2RadialLimitSwitch == LOW) {
    StepperMotor (1);
  }
  else{
    Ring2RadialEncoder=0;
  }
  digitalRead(Ring2AxialLimitSwitch);
  if (Ring2AxialLimitSwitch == LOW) {
    StepperMotor (1);
  }
  else{
    Ring2AxialEncoder=0;
  }
}
}

void loop() {
  if (Serial.available() > 0) {
  // ASCII '0' through '9' characters are represented by the values 48 through 57
  // so if the user types a number from 0 through 9 in ASCII, you can subtract 48 to get the actual value:
    int bitToSet = Serial.read() - 48;

  // write to the shift register with the correct bit set high:
    registerWrite(bitToSet, HIGH, 1);
    registerWrite(bitToSet, HIGH, 2);
  }
  StartUp();
}
